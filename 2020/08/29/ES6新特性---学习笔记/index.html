

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="violateer">
  <meta name="keywords" content="">
  <title>ES6新特性 - Violateer</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Violateer</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-08-29 02:52" pubdate>
      2020年8月29日 凌晨
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      100
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">ES6新特性</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li><p><strong>ECMAScript</strong>是一种由ECMA国际在标准ECMA-262中定义的<strong>脚本语言规范</strong>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://kangax.github.io/compat-table/es6/">查看ECS6兼容性支持</a></p>
</li>
</ul>
<h2 id="2-let关键字"><a href="#2-let关键字" class="headerlink" title="2.let关键字"></a>2.let关键字</h2><ul>
<li><p>变量不能重复声明</p>
</li>
<li><p>块级作用域</p>
<pre><code class="hljs js">&#123;
	<span class="hljs-keyword">let</span> a=<span class="hljs-number">100</span>;
&#125;  
<span class="hljs-built_in">console</span>.log(a);
<span class="hljs-comment">//以上代码会报错，在作用域外部无法访问到&#x27;a&#x27;变量</span>
<span class="hljs-comment">//如果是var变量就可以访问到(变量提升)</span></code></pre>
</li>
<li><p>不存在变量提升</p>
<p><strong>var:</strong></p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); 
<span class="hljs-keyword">var</span> a=<span class="hljs-number">100</span>;  
<span class="hljs-comment">// 输出 undefined</span>
<span class="hljs-comment">// var变量进行变量提升，上述代码相当于在代码最开始进行变量声明 var a; 但未进行赋值</span></code></pre>
<p><strong>let:</strong></p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); 
<span class="hljs-keyword">let</span> a=<span class="hljs-number">100</span>;  
<span class="hljs-comment">// 报错</span></code></pre>
</li>
<li><p>不影响作用域链</p>
<pre><code class="hljs js">&#123;
	<span class="hljs-keyword">let</span> a=<span class="hljs-number">100</span>;
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
		<span class="hljs-built_in">console</span>.log(a);
	&#125;
	fn();
&#125;
<span class="hljs-comment">// 程序能够正常运行</span></code></pre>

</li>
</ul>
<h2 id="2-const关键字"><a href="#2-const关键字" class="headerlink" title="2.const关键字"></a>2.const关键字</h2><ul>
<li><p>常量</p>
</li>
<li><p>一定要赋初始值</p>
</li>
<li><p>常量的值不能修改</p>
</li>
<li><p>块级作用域</p>
<pre><code class="hljs js">&#123;
	<span class="hljs-keyword">const</span> a=<span class="hljs-number">100</span>;
&#125;  
<span class="hljs-built_in">console</span>.log(a);
<span class="hljs-comment">// 报错</span></code></pre>
</li>
<li><p>对于数组和元素的修改，不算做对常量的修改</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> FRUIT = [<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;banana&#x27;</span>,<span class="hljs-string">&#x27;watermelon&#x27;</span>];
FRUIT.push(<span class="hljs-string">&#x27;pear&#x27;</span>);
<span class="hljs-built_in">console</span>.log(FRUIT);
<span class="hljs-comment">// 不会报错，输出[&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;]</span>
<span class="hljs-comment">// FRUIT常量对应的地址没有发生改变，改变的是地址里面的内容</span></code></pre>



</li>
</ul>
<h2 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h2><ul>
<li><p>ES6允许按照一定模式从<strong>数组</strong>和<strong>对象</strong>中提取值，对<strong>变量</strong>进行<strong>赋值</strong></p>
</li>
<li><p>数组的解构</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> A = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>];
<span class="hljs-keyword">let</span> [one, two, three, four] = A;
<span class="hljs-built_in">console</span>.log(one);
<span class="hljs-built_in">console</span>.log(two);
<span class="hljs-built_in">console</span>.log(three);
<span class="hljs-built_in">console</span>.log(four);
<span class="hljs-comment">// 输出 a, b, c, d</span>
<span class="hljs-comment">// 相当于对4个变量进行了赋值操作</span>
<span class="hljs-comment">// 如果两边数量不相等，将会按顺序进行赋值，没有对应的变量或数据则不进行操作</span></code></pre>
</li>
<li><p>对象的解构</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> zhang = &#123;
    name: <span class="hljs-string">&#x27;张三&#x27;</span>,
    age: <span class="hljs-number">24</span>,
    sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hi&quot;</span>);
    &#125;
&#125;;
<span class="hljs-keyword">let</span> &#123;name, age, sayHi&#125; = zhang;
<span class="hljs-built_in">console</span>.log(name);
<span class="hljs-built_in">console</span>.log(age);
<span class="hljs-built_in">console</span>.log(sayHi);
<span class="hljs-comment">// 相当于赋值操作</span>
<span class="hljs-comment">// 对象的解构赋值需要对应的属性名相同</span>
<span class="hljs-comment">// 即便两边数量不相等，则寻找同名属性进行赋值</span></code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// 其中方法解构能够较好的降低代码重复率</span>
<span class="hljs-comment">// 在上方代码块中，若不进行方法解构，调用函数时必须写为 zhang.sayHi();</span>
<span class="hljs-comment">// 解构赋值之后，则可以写为 sayHi();</span></code></pre>

</li>
</ul>
<h2 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="4.模板字符串"></a>4.模板字符串</h2><ul>
<li><p>ES6引入了新的字符串声明方式    <strong>反引号</strong>—<strong>``</strong></p>
</li>
<li><p>使用``也可以声明字符串，效果同’’  “”</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`I&#x27;m a string`</span>;</code></pre>
</li>
<li><p>内容中可以直接出现换行符</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;a</span>
<span class="hljs-string">		   b</span>
<span class="hljs-string">           c&#x27;</span>;
<span class="hljs-comment">// 单引号和双引号这么写是不允许的，会报错</span>
<span class="hljs-comment">// 想要完成换行效果需要写为 let str = &#x27;a&#x27; + &#x27;\n&#x27; + &#x27;b&#x27; + &#x27;\n&#x27; + &#x27;c&#x27;;</span></code></pre>

<pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`a</span>
<span class="hljs-string">		   b</span>
<span class="hljs-string">		   c`</span>;
<span class="hljs-comment">// 反引号声明的字符串中允许出现换行符</span></code></pre>
</li>
<li><p>变量拼接</p>
<pre><code class="hljs js"><span class="hljs-comment">// 单引号和双引号</span>
<span class="hljs-keyword">let</span> zhang = <span class="hljs-string">&quot;张三&quot;</span>;
<span class="hljs-keyword">let</span> hi = <span class="hljs-string">&quot;你好，&quot;</span>;
<span class="hljs-comment">// 进行拼接</span>
<span class="hljs-keyword">let</span> sayHi = hi + zhang;
<span class="hljs-built_in">console</span>.log(sayHi);
<span class="hljs-comment">// 输出 你好，张三</span></code></pre>
<pre><code class="hljs js"><span class="hljs-comment">// 反引号    在``中使用  $&#123;&#125;  模板</span>
<span class="hljs-keyword">let</span> zhang = <span class="hljs-string">&quot;张三&quot;</span>;
<span class="hljs-keyword">let</span> sayhi = <span class="hljs-string">`你好，<span class="hljs-subst">$&#123;zhang&#125;</span>`</span>;
<span class="hljs-built_in">console</span>.log(sayhi);
<span class="hljs-comment">// 输出 你好，张三</span></code></pre>


</li>
</ul>
<h2 id="5-对象的简化写法"><a href="#5-对象的简化写法" class="headerlink" title="5.对象的简化写法"></a>5.对象的简化写法</h2><ul>
<li><p>ES6中允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;张三&quot;</span>；
<span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);
&#125;
<span class="hljs-keyword">const</span> zhang = &#123;
    name,	<span class="hljs-comment">// 等效于 name: &quot;张三&quot;</span>
    sayHi,	<span class="hljs-comment">// 等效于 sayHi: function() &#123; console.log(&#x27;Hello&#x27;); &#125;</span>
    study()&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我在学习&#x27;</span>);
    &#125;		<span class="hljs-comment">// 等效于 study: function() &#123; console.log(&#x27;我在学习&#x27;); &#125;</span>
&#125;</code></pre>

</li>
</ul>
<h2 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6.箭头函数"></a>6.箭头函数</h2><ul>
<li><p>ES6允许使用箭头 =&gt; 来定义函数</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;
    value = <span class="hljs-string">&quot;Hello&quot;</span>;
    <span class="hljs-built_in">console</span>.log(value);
&#125;</code></pre>
</li>
<li><p>==<strong>this</strong>的指向是静态的，<strong>this</strong>始终指向函数声明时所在作用域下的<strong>this</strong>的值==</p>
<pre><code class="hljs js"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName1</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
&#125;

<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">let</span> getName2 = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);
&#125;

<span class="hljs-comment">//设置window对象的name属性 </span>
<span class="hljs-built_in">window</span>.name = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;
<span class="hljs-keyword">const</span> person = &#123;
    name: <span class="hljs-string">&#x27;lisi&#x27;</span>
&#125;

<span class="hljs-comment">// 直接调用</span>
getName1();		<span class="hljs-comment">// 输出 zhangsan </span>
getName2();		<span class="hljs-comment">// 输出 zhangsan</span>

<span class="hljs-comment">// call方法调用  call可以改变函数内部的this值</span>
getName1.call(person);	<span class="hljs-comment">// 输出lisi</span>
getName2.call(person);	<span class="hljs-comment">// 输出zhangsan</span>
<span class="hljs-comment">//箭头函数的this始终指向函数声明时所在作用域下的this值</span></code></pre>
</li>
<li><p>不能作为构造函数实例化对象</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> Person = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> &#123;
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.age = age;
&#125;
<span class="hljs-keyword">let</span> zhangsan = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// 报错</span>
<span class="hljs-comment">// 箭头函数不能作为构造函数</span></code></pre>
</li>
<li><p>不能使用 <strong>arguments</strong> 变量</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> fn = <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
&#125;
fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);
<span class="hljs-comment">// 报错</span></code></pre>
</li>
<li><p>简写</p>
<ul>
<li><p>省略小括号</p>
<pre><code class="hljs js"><span class="hljs-comment">// 当形参有且只有一个时可以省略小括号</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> num + num;
&#125;
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">9</span>));</code></pre>
</li>
<li><p>省略大括号，当代码体只有一条语句的时候，将大括号省略，<strong>return</strong>也要一起省略，此时语句的执行结果就是函数的返回值</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> add = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num + num;
<span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">9</span>));</code></pre>
</li>
</ul>
</li>
<li><p>箭头函数<strong>适用</strong>于与<strong>this</strong>无关的回调，例如定时器，数组的方法回调，不<strong>适用</strong>于与<strong>this</strong>有关的回调，例如事件的回调函数，对象的方法函数</p>
</li>
</ul>
<h2 id="7-函数参数的默认值设置"><a href="#7-函数参数的默认值设置" class="headerlink" title="7.函数参数的默认值设置"></a>7.函数参数的默认值设置</h2><ul>
<li><p>形参的初始值        具有默认值的参数，一般位置要靠后</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c</span>)</span>&#123;
    <span class="hljs-keyword">return</span> a + b + c;
&#125;
<span class="hljs-keyword">let</span> result = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(result);	<span class="hljs-comment">// 输出为 NaN</span></code></pre>

<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c=<span class="hljs-number">10</span></span>)</span>&#123;
    <span class="hljs-keyword">return</span> a + b + c;
&#125;
<span class="hljs-keyword">let</span> result1 = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">let</span> result2 = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(result1);	<span class="hljs-comment">// 输出为 13</span>
<span class="hljs-built_in">console</span>.log(result2);	<span class="hljs-comment">// 输出为 6</span></code></pre>
</li>
<li><p>可以与解构赋值结合使用</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">host, username, password, port</span>)</span>&#123;
	<span class="hljs-built_in">console</span>.log(host);
    <span class="hljs-built_in">console</span>.log(username);
    <span class="hljs-built_in">console</span>.log(password);
    <span class="hljs-built_in">console</span>.log(port);
    <span class="hljs-comment">// 能够输出对应值</span>
&#125;
connect(&#123;
    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,
    username: <span class="hljs-string">&#x27;root&#x27;</span>,
    password: <span class="hljs-string">&#x27;root&#x27;</span>,
    port: <span class="hljs-number">1234</span>
&#125;)</code></pre>

<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, username, password, port</span>)</span>&#123;
	<span class="hljs-built_in">console</span>.log(host);	<span class="hljs-comment">// 输出 127.0.0.1</span>
    <span class="hljs-built_in">console</span>.log(username);
    <span class="hljs-built_in">console</span>.log(password);
    <span class="hljs-built_in">console</span>.log(port);
&#125;
connect(&#123;
    username: <span class="hljs-string">&#x27;root&#x27;</span>,
    password: <span class="hljs-string">&#x27;root&#x27;</span>,
    port: <span class="hljs-number">1234</span>
&#125;)</code></pre>

</li>
</ul>
<h2 id="8-rest参数"><a href="#8-rest参数" class="headerlink" title="8.rest参数"></a>8.<strong>rest</strong>参数</h2><ul>
<li><p>ES6引入<strong>rest</strong>参数，用于获取函数的实参，用以代替<strong>arguments</strong></p>
</li>
<li><p><strong>rest</strong>参数可以用到箭头函数中</p>
</li>
<li><p><strong>rest</strong>参数 … 放于函数<strong>形参</strong>中</p>
<pre><code class="hljs js"><span class="hljs-comment">// ES5中arguments参数演示</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
&#125;
data(<span class="hljs-string">&#x27;first&#x27;</span>,<span class="hljs-string">&#x27;second&#x27;</span>,<span class="hljs-string">&#x27;third&#x27;</span>);
<span class="hljs-comment">// arguments是一个对象</span>


<span class="hljs-comment">// ES6中rest参数演示</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params">...args</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(args);
&#125;
data(<span class="hljs-string">&#x27;first&#x27;</span>,<span class="hljs-string">&#x27;second&#x27;</span>,<span class="hljs-string">&#x27;third&#x27;</span>);
<span class="hljs-comment">// args是一个数组</span></code></pre>
</li>
<li><p><strong>rest</strong>参数必须放到参数的最后</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b, ...args</span>) </span>&#123;
	<span class="hljs-built_in">console</span>.log(a);		<span class="hljs-comment">// 输出 1</span>
	<span class="hljs-built_in">console</span>.log(b);		<span class="hljs-comment">// 输出 2</span>
	<span class="hljs-built_in">console</span>.log(args);	<span class="hljs-comment">// 输出[3, 4, 5, 6]</span>
&#125;
fn(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);</code></pre>

</li>
</ul>
<h2 id="9-扩展运算符"><a href="#9-扩展运算符" class="headerlink" title="9.扩展运算符"></a>9.扩展运算符</h2><ul>
<li><p>扩展运算符   <strong>…</strong></p>
</li>
<li><p>能将<strong>数组</strong>转换为<strong>逗号</strong>分隔的<strong>参数序列</strong></p>
</li>
<li><p>扩展运算符 …  放于函数<strong>实参</strong>中</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> query = [<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-string">&#x27;second&#x27;</span>, <span class="hljs-string">&#x27;third&#x27;</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitQuery</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
&#125;
splitQuery(...query); 	<span class="hljs-comment">// 等同于 splitQuery(&#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27;)</span></code></pre>
</li>
<li><p>应用</p>
<ul>
<li><p>数组的合并</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> first = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>];
<span class="hljs-keyword">const</span> second = [<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>];

<span class="hljs-comment">// ES5中</span>
<span class="hljs-keyword">const</span> result1 = first.concat(second);
<span class="hljs-built_in">console</span>.log(result1);	<span class="hljs-comment">// 输出 [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span>

<span class="hljs-comment">// ES6中</span>
<span class="hljs-keyword">const</span> result2 = [...first, ...second];
<span class="hljs-built_in">console</span>.log(result2);	<span class="hljs-comment">// 输出 [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></code></pre>
</li>
<li><p>数组的克隆</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> first = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>];
<span class="hljs-keyword">const</span> cloned = [...first];
<span class="hljs-built_in">console</span>.log(cloned);	<span class="hljs-comment">// 输出 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span></code></pre>
</li>
<li><p>将伪数组转为数组</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);	 <span class="hljs-comment">// 这里输出的是一个伪数组</span>
    <span class="hljs-built_in">console</span>.log([...arguments]);	<span class="hljs-comment">// 这里输出的是一个数组</span>
&#125;
data(<span class="hljs-string">&#x27;first&#x27;</span>,<span class="hljs-string">&#x27;second&#x27;</span>,<span class="hljs-string">&#x27;third&#x27;</span>);</code></pre>

</li>
</ul>
</li>
</ul>
<h2 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10.Symbol"></a>10.Symbol</h2><ul>
<li><p>ES6引入了一种新的<strong>原始数据类型</strong>，表示独一无二的值</p>
</li>
<li><p>Symbol是Javascript语言的第七种数据类型，是一种类似于字符串的数据类型</p>
</li>
<li><p>特点</p>
<ul>
<li>Symbol的值是唯一的，用来解决命名冲突的问题</li>
<li>Symbol值不能与其他数据进行运算</li>
<li>Symbol定义的对象属性不能使用 for…in 循环遍历，但是可以使用 <strong>Reflect.ownKeys</strong> 来获取对象的所有键名</li>
</ul>
</li>
<li><p>创建Symbol</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);	<span class="hljs-comment">// 括号内的字符串起描述的作用</span>
<span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);
<span class="hljs-built_in">console</span>.log(s2 === s3);	<span class="hljs-comment">// 输出 fasle，这里的s2和s3是两个不同的数据</span>

<span class="hljs-comment">// Symbol.for创建</span>
<span class="hljs-keyword">let</span> s4 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;hello&#x27;</span>);
<span class="hljs-keyword">let</span> s5 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;hello&#x27;</span>);
<span class="hljs-built_in">console</span>.log(s4 === s5);	<span class="hljs-comment">// 输出true，这里的s4和s5是相同的数据</span>

<span class="hljs-comment">// 不能与其他数据进行运算</span>
<span class="hljs-keyword">let</span> result1 = s1 + <span class="hljs-number">100</span>;	<span class="hljs-comment">// 四则运算，报错</span>
<span class="hljs-keyword">let</span> result2 = s1 &gt; <span class="hljs-number">100</span>;	<span class="hljs-comment">// 比较，报错</span>
<span class="hljs-keyword">let</span> result3 = s1 + <span class="hljs-string">&#x27;hi&#x27;</span>; <span class="hljs-comment">// 字符串拼接，报错</span></code></pre>
</li>
<li><p>Javascript语言的八种数据类型</p>
<ul>
<li>undefined</li>
<li>string</li>
<li>object</li>
<li>null</li>
<li>number   </li>
<li>boolean</li>
<li>symbol</li>
<li>BigInt(新增)</li>
</ul>
</li>
<li><p>Symbol创建对象属性</p>
<ul>
<li><p>向对象中添加方法</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> game = &#123;
    name: <span class="hljs-string">&#x27;俄罗斯方块&#x27;</span>,
    up: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;up&#x27;</span>);
    &#125;
&#125;

<span class="hljs-comment">//现在要向game对象中添加方法，但是在实际开发中要花费时间去确定game对象中是否已经存在要添加的方法，或者要分析game对象的结构，如果game对象的结构较为复杂，则会花费大量的事件</span>

<span class="hljs-comment">// 使用Symbol向对象中添加方法(1)</span>
<span class="hljs-comment">// 先声明一个对象</span>
<span class="hljs-keyword">let</span> methods = &#123;
    up: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;up&#x27;</span>),
    down: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;down&#x27;</span>)
&#125;;
game[methods.up] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;向上&#x27;</span>);
&#125;;
game[methods.down] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;向下&#x27;</span>);
&#125;
<span class="hljs-comment">// 调用添加的方法</span>
game[methods.up]();	<span class="hljs-comment">// 输出 向上</span>
game[methods.down]();	<span class="hljs-comment">// 输出 向下</span></code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// 使用Symbol向对象中添加方法(2)</span>
<span class="hljs-keyword">let</span> say = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;say&#x27;</span>);
<span class="hljs-keyword">let</span> zibao = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;zibao&#x27;</span>);
<span class="hljs-keyword">let</span> game = &#123;
    name: <span class="hljs-string">&#x27;狼人杀&#x27;</span>,
    [say]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以发言&#x27;</span>);
    &#125;,
    [zibao]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以自爆&#x27;</span>);
    &#125;
&#125;

<span class="hljs-comment">// 调用</span>
game[say]();	<span class="hljs-comment">// 输出 我可以发言</span></code></pre>

</li>
</ul>
</li>
</ul>
<h2 id="11-迭代器iterator"><a href="#11-迭代器iterator" class="headerlink" title="11.迭代器iterator"></a>11.迭代器iterator</h2><ul>
<li><p>迭代器<strong>Iterator</strong>是一种接口，为各种不同的数据结构提供统一得到访问机制</p>
</li>
<li><p><strong>iterator</strong>接口是对象的一个属性，即Symbol.iterator</p>
</li>
<li><p>任何数据结构只要部署<strong>Iterator</strong>接口，就可以完成遍历操作</p>
</li>
<li><p>ES6创造了一种新的遍历命令  <strong>for…of</strong>  循环，Iteraotr接口主要供  <strong>for…of</strong>  消费</p>
</li>
<li><p>原生具备<strong>iterator</strong>接口的数据（可用<strong>for…of</strong>遍历）</p>
<ul>
<li>Array</li>
<li>Arguments</li>
<li>Set</li>
<li>Map</li>
<li>String</li>
<li>TypedArray</li>
<li>NodeList</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;唐僧&#x27;</span>, <span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-string">&#x27;沙僧&#x27;</span>];
<span class="hljs-comment">// 使用for...of遍历数组</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> xiyou)&#123;
    <span class="hljs-built_in">console</span>.log(v);	<span class="hljs-comment">// 输出键值：唐僧, 孙悟空, 猪八戒, 沙僧</span>
&#125;
<span class="hljs-comment">// 使用for...in遍历数组</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">in</span> xiyou)&#123;
    consoole.log(v) <span class="hljs-comment">// 输出键名：0, 1, 2, 3</span>
&#125;</code></pre>
</li>
<li><p>工作原理</p>
<ul>
<li><p>创建一个指针<strong>对象</strong>，指向当前数据结构的起始位置</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;唐僧&#x27;</span>, <span class="hljs-string">&#x27;孙悟空&#x27;</span>, <span class="hljs-string">&#x27;猪八戒&#x27;</span>, <span class="hljs-string">&#x27;沙僧&#x27;</span>];

<span class="hljs-keyword">let</span> iterator = xiyou[<span class="hljs-built_in">Symbol</span>.iterator]();</code></pre>
</li>
<li><p>第一次调用对象的<strong>next</strong>方法，指针自动指向数据结构的第一个成员</p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 输出 &#123;value: &quot;唐僧&quot;, done: false&#125;</span></code></pre>
</li>
<li><p>接下来不断调用<strong>next</strong>方法，指针一直往后移动，直到指向最后一个成员</p>
</li>
<li><p>每调用<strong>next</strong>方法返回一个包含<strong>value</strong>和<strong>done</strong>属性的对象</p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 输出 &#123;value: &quot;孙悟空&quot;, done: false&#125;</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 输出 &#123;value: &quot;猪八戒&quot;, done: false&#125;</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 输出 &#123;value: &quot;沙僧&quot;, done: false&#125;</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 输出 &#123;value: undefined, done: true&#125;</span>
								<span class="hljs-comment">// done属性为true则说明遍历或循环已完成</span></code></pre>
</li>
</ul>
</li>
<li><p>应用—自定义遍历对象</p>
<pre><code class="hljs js"><span class="hljs-comment">// 声明一个对象</span>
<span class="hljs-keyword">const</span> banji = &#123;
    name: <span class="hljs-string">&#x27;1班&#x27;</span>,
    students: [<span class="hljs-string">&#x27;Marry&#x27;</span>, <span class="hljs-string">&#x27;Jhon&#x27;</span>, <span class="hljs-string">&#x27;Brown&#x27;</span>, <span class="hljs-string">&#x27;Kelly&#x27;</span>],
    [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;
        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> &#123;	<span class="hljs-comment">// 创建(返回)一个指针对象</span>
            next: <span class="hljs-function">() =&gt;</span> &#123;	<span class="hljs-comment">// 添加next方法</span>
                <span class="hljs-comment">//  next要返回一个包含value和done的对象</span>
                <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-built_in">this</span>.students.length)&#123;
                    <span class="hljs-keyword">const</span> result = &#123; <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.students[index], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;;
                    index++;
                    <span class="hljs-keyword">return</span> result;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 遍历这个对象</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> banji)&#123;
    <span class="hljs-built_in">console</span>.log(v);
&#125;	
<span class="hljs-comment">// 输出  Marry  Jhon   Brown   Kelly</span></code></pre>

</li>
</ul>
<h2 id="12-生成器generator"><a href="#12-生成器generator" class="headerlink" title="12.生成器generator"></a>12.生成器generator</h2><ul>
<li><p>生成器是一个特殊的<strong>函数</strong></p>
</li>
<li><p>生成器<strong>函数</strong>是ES6提供的一种<strong>异步编程</strong>解决方案，语法行为与传统函数完全不同</p>
<pre><code class="hljs js"><span class="hljs-comment">// 定义</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);
&#125;
<span class="hljs-keyword">let</span> iterator = gen();
<span class="hljs-built_in">console</span>.log(iterator);	<span class="hljs-comment">// 从此处结果可以看出生成器函数的返回结果是一个迭代器对象</span>

<span class="hljs-comment">// 调用函数内部代码</span>
iterator.next();	<span class="hljs-comment">// 输出hello</span></code></pre>
</li>
<li><p>函数代码的分隔符 <strong>yield</strong></p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第一块代码&#x27;</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;引号内容&#x27;</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第二块代码&#x27;</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;引号内容可写可不写&#x27;</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第三块代码&#x27;</span>);
    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;引号内容可以被遍历出来&#x27;</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第四块代码&#x27;</span>);
&#125;

<span class="hljs-keyword">let</span> iterator = gen();
<span class="hljs-comment">// 调用代码块</span>
iterator.next();	<span class="hljs-comment">// 输出 第一块代码</span>
iterator.next();	<span class="hljs-comment">// 输出 第二块代码</span>
iterator.next();	<span class="hljs-comment">// 输出 第三块代码</span>
iterator.next();	<span class="hljs-comment">// 输出 第四块代码</span>
<span class="hljs-comment">// 调用代码块的返回值</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 先运行代码块，然后返回&#123; value: &quot;引号内容&quot;, done: false&#125;</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 先运行代码块，然后返回&#123; value: &quot;引号内容可写可不写&quot;, done: false&#125;</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 先运行代码块，然后返回&#123; value: &quot;引号内容可以被遍历出来&quot;, done: false&#125;</span>
<span class="hljs-built_in">console</span>.log(iterator.next());	<span class="hljs-comment">// 先运行代码块，然后返回&#123; value: undefined, done: true&#125;</span></code></pre>
</li>
<li><p>生成器函数的参数传递</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params">arg</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(arg);
    <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">yield</span> <span class="hljs-number">111</span>;
    <span class="hljs-built_in">console</span>.log(one);
    <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">yield</span> <span class="hljs-number">222</span>;
    <span class="hljs-built_in">console</span>.log(two);
    <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">yield</span> <span class="hljs-number">333</span>;
    <span class="hljs-built_in">console</span>.log(three);
&#125;
<span class="hljs-keyword">let</span> iterator = gen(<span class="hljs-string">&#x27;AAA&#x27;</span>);	<span class="hljs-comment">// 首次传参要在这里传入</span>
iterator.next();	<span class="hljs-comment">// 输出 AAA，如果上一行代码没有传入参数，在这里传入的话，输出undefined</span>
iterator.next(<span class="hljs-string">&#x27;BBB&#x27;</span>);	<span class="hljs-comment">// 第二次调用next方法传入的参数将作为第一次 yield 语句返回的结果  						 // 执行第二段代码块，输出 BBB</span>
iterator.next(<span class="hljs-string">&#x27;CCC&#x27;</span>);	<span class="hljs-comment">// 第三次调用next方法传入的参数将作为第二次 yield 语句返回的结果  						 // 执行第三段代码块，输出 CCC</span>
iterator.next(<span class="hljs-string">&#x27;DDD&#x27;</span>);	<span class="hljs-comment">// 第四次调用next方法传入的参数将作为第三次 yield 语句返回的结果  						 // 执行第四段代码块，输出 CCC</span></code></pre>
</li>
<li><p>实例1—回调地狱</p>
<pre><code class="hljs js"><span class="hljs-comment">// 异步编程</span>
<span class="hljs-comment">// 需求：1s后控制台输出 111， 2s后输出 222， 3s后输出 333</span>

<span class="hljs-comment">// 回调地狱</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
            <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>);
        &#125;,<span class="hljs-number">3000</span>)
    &#125;,<span class="hljs-number">2000</span>)
&#125;,<span class="hljs-number">1000</span>);
<span class="hljs-comment">// 上述代码，需要进行的异步任务越多，代码缩进越多，导致代码可读性差，调试困难---回调地狱</span>

<span class="hljs-comment">// 生成器函数实现</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);
        iterator.next();	<span class="hljs-comment">// 第一次调用完next后接着调用下一次</span>
    &#125;,<span class="hljs-number">1000</span>)
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">two</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);
        iterator.next();	<span class="hljs-comment">// 第二次调用完next后接着调用下一次</span>
    &#125;,<span class="hljs-number">2000</span>)
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>);
    &#125;,<span class="hljs-number">3000</span>)
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">yield</span> one();
    <span class="hljs-keyword">yield</span> two();
    <span class="hljs-keyword">yield</span> three();
&#125;
<span class="hljs-comment">// 调用生成器函数</span>
<span class="hljs-keyword">let</span> iterator = gen();
iterator.next();</code></pre>
</li>
<li><p>实例2—模拟获取</p>
<pre><code class="hljs js"><span class="hljs-comment">// 模拟获取---用户数据/订单数据/商品数据</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUsers</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
      <span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;用户数据&quot;</span>;
      iterator.next(data); <span class="hljs-comment">// 第二次调用生成器函数，传入的数据会作为第一个yield的返回值</span>
  &#125;, <span class="hljs-number">1000</span>)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOrders</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
      <span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;订单数据&quot;</span>;
      iterator.next(data); <span class="hljs-comment">// 第三次调用生成器函数，传入的数据会作为第二个yield的返回值</span>
  &#125;, <span class="hljs-number">1000</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGoods</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
      <span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;商品数据&quot;</span>;
      iterator.next(data); <span class="hljs-comment">// 第四次调用生成器函数，传入的数据会作为第三个yield的返回值</span>
  &#125;, <span class="hljs-number">1000</span>);
&#125;

<span class="hljs-comment">// 在实际应用中需要先有用户数据，才能有订单数据，再有商品数据，所以不能直接</span>
<span class="hljs-comment">// getUsers();getOrders();getGoods();</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span> (<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">let</span> users = <span class="hljs-keyword">yield</span> getUsers();
  <span class="hljs-built_in">console</span>.log(users);		<span class="hljs-comment">// 输出 用户数据</span>
  <span class="hljs-keyword">let</span> orders = <span class="hljs-keyword">yield</span> getOrders();
  <span class="hljs-built_in">console</span>.log(orders);	<span class="hljs-comment">// 输出 订单数据</span>
  <span class="hljs-keyword">let</span> goods = <span class="hljs-keyword">yield</span> getGoods();
  <span class="hljs-built_in">console</span>.log(goods);		<span class="hljs-comment">// 输出 商品数据</span>
&#125;
<span class="hljs-keyword">let</span> iterator = gen();
iterator.next();	<span class="hljs-comment">// 第一次调用生成器函数</span></code></pre>


</li>
</ul>
<h2 id="13-Promise"><a href="#13-Promise" class="headerlink" title="13.Promise"></a>13.Promise</h2><ul>
<li><p><strong>Promise</strong>是ES6引入的异步编程的新解决方案</p>
</li>
<li><p>语法上<strong>Promise</strong>是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果</p>
<pre><code class="hljs js"><span class="hljs-comment">// 实例化一个Promise对象	对象一共有三种状态：初始化，成功，失败</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>();	<span class="hljs-comment">// 此时p的状态为 初始化</span></code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// 实例化时Promise对象接收一个函数参数，函数往往封装一个异步操作</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-comment">// 模拟成功</span>
        <span class="hljs-keyword">let</span> data = <span class="hljs-string">&quot;数据库中的用户数据&quot;</span>;
        resolve(data);	<span class="hljs-comment">// 调用resolve后，设置p的状态为 成功</span>
        
        <span class="hljs-comment">// 模拟失败</span>
        <span class="hljs-keyword">let</span> err = <span class="hljs-string">&quot;数据读取失败&quot;</span>;
        reject(err);	<span class="hljs-comment">// 调用reject后，设置p的状态为 失败</span>
    &#125;,<span class="hljs-number">1000</span>)
&#125;);

<span class="hljs-comment">// 可以调用promise对象的then方法</span>
<span class="hljs-comment">// then方法接收两个函数参数,第一个是成功之后的回调，第二个是失败之后的回调</span>
p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;
    <span class="hljs-comment">// 对象的异步操作中调用resolve即成功后，then方法就会执行第一个回调函数</span>
    <span class="hljs-built_in">console</span>.log(value);
&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.error(reason);
&#125;);</code></pre>
</li>
<li><p>实例—使用Promise封装AJAX请求</p>
<pre><code class="hljs js"><span class="hljs-comment">// 1.创建对象</span>
<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// 2.初始化</span>
	xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);

	<span class="hljs-comment">// 3.发送</span>
	xhr.send();

	<span class="hljs-comment">// 4.绑定事件</span>
	xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
 	   <span class="hljs-comment">// 判断</span>
 	   <span class="hljs-keyword">if</span>(xhr.readyState === <span class="hljs-number">4</span>) &#123;
  	      <span class="hljs-comment">// 判断响应状态码---200到300之间为成功</span>
   	     <span class="hljs-keyword">if</span>(xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) &#123;
   	         resolve(xhr.response);
     	 &#125; <span class="hljs-keyword">else</span> &#123;
     	       reject(xhr.status);
         &#125;
   	   &#125;
	&#125;
&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(value);
&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(reason);
&#125;);</code></pre>
</li>
<li><p><strong>then</strong>方法的返回对象</p>
<pre><code class="hljs js"><span class="hljs-comment">// 创建Promise对象</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
       resolve(<span class="hljs-string">&#x27;用户数据&#x27;</span>);
   &#125;,<span class="hljs-number">1000</span>); 
&#125;);

<span class="hljs-comment">// 调用then方法</span>
<span class="hljs-comment">// then方法的返回结果是Promise对象，对象状态由回调函数的执行结果决定</span>
<span class="hljs-comment">// 1.如果回调函数中返回的结果是非promise类型的属性，且状态为成功，则返回对象PromiseStatus为		 fulfilled，返回值PromiseValue为成功的值</span>
<span class="hljs-keyword">const</span> result = p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(value);
    <span class="hljs-comment">// 返回非promise类型的值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;
&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.warn(reason);
&#125;);
<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// 若成功：PromiseStatus为fulfilled，PromiseValue为123</span></code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// 创建Promise对象</span>
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
       resolve(<span class="hljs-string">&#x27;用户数据&#x27;</span>);
   &#125;,<span class="hljs-number">1000</span>); 
&#125;);

<span class="hljs-comment">// 调用then方法</span>
<span class="hljs-comment">// then方法的返回结果是Promise对象，对象状态由回调函数的执行结果决定</span>
<span class="hljs-comment">// 2.如果回调函数中返回的结果是promise类型的属性，且状态为成功，则返回对象PromiseStatus为	//   返回的promise对象的状态值（成功/失败），返回值PromiseValue为返回的promise对象成功/失败  //   的值</span>
<span class="hljs-keyword">const</span> result = p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.log(value);
    <span class="hljs-comment">// 返回promise类型的值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
        resolve(<span class="hljs-string">&#x27;OK&#x27;</span>);<span class="hljs-comment">// 若p成功：PromiseStatus为fulfilled，PromiseValue为OK</span>
        reject(<span class="hljs-string">&#x27;error&#x27;</span>);<span class="hljs-comment">// 若p成功：PromiseStatus为rejected，PromiseValue为error</span>
        <span class="hljs-comment">// 失败还可以写为抛出错误   throw &#x27;error&#x27;;  结果一样</span>
    &#125;);
&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.warn(reason);
&#125;);
<span class="hljs-built_in">console</span>.log(result);</code></pre>
</li>
<li><p>then方法的链式调用</p>
<pre><code class="hljs js">p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;&#125;);
<span class="hljs-comment">// 链式调用也是解决回调地狱的一种方法</span></code></pre>
</li>
<li><p>catch方法</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
        <span class="hljs-comment">// 设置p的状态为 失败，并设置失败的值</span>
        reject(<span class="hljs-string">&#x27;error&#x27;</span>);
    &#125;, <span class="hljs-number">1000</span>);
&#125;);
<span class="hljs-comment">// then方法</span>
<span class="hljs-comment">// p.then(reason =&gt; &#123;</span>
<span class="hljs-comment">//     console.error(reason);</span>
<span class="hljs-comment">// &#125;);</span>
<span class="hljs-comment">// catch方法</span>
p.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;
    <span class="hljs-built_in">console</span>.error(reason);
&#125;);</code></pre>

</li>
</ul>
<h2 id="14-Set"><a href="#14-Set" class="headerlink" title="14.Set"></a>14.Set</h2><ul>
<li><p>ES6提供了新的数据结构<strong>Set</strong>(集合)</p>
<pre><code class="hljs js"><span class="hljs-comment">// 声明一个集合</span>
<span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
<span class="hljs-built_in">console</span>.log(s, <span class="hljs-keyword">typeof</span> s); <span class="hljs-comment">// 输出 Set[0]&#123;&#125;    &quot;object&quot;</span></code></pre>
</li>
<li><p><strong>Set</strong>类似于数组，但成员的值都是唯一的</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]);
<span class="hljs-built_in">console</span>.log(s);	<span class="hljs-comment">// 输出 Set[4]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span>
<span class="hljs-comment">// 传入数据时会自动去重</span></code></pre>
</li>
<li><p>集合的属性和方法</p>
<ul>
<li><p><strong>size</strong>    返回集合的元素个数</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]);
<span class="hljs-built_in">console</span>.log(s.size); <span class="hljs-comment">// 输出 4</span></code></pre>
</li>
<li><p><strong>add</strong>    增加一个新的元素，返回当前集合</p>
<pre><code class="hljs js">s.add(<span class="hljs-string">&#x27;E&#x27;</span>);
<span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">// 输出 Set[5]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;</span></code></pre>
</li>
<li><p><strong>delete</strong>    删除元素，返回boolean值</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> result = s.delete(<span class="hljs-string">&#x27;D&#x27;</span>);
<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">//输出 true </span>
<span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">// 输出 Set[4]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;E&quot;&#125;</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;H&#x27;</span>); <span class="hljs-comment">// 输出false</span></code></pre>
</li>
<li><p><strong>has</strong>    检测集合中是否包含某个元素，返回boolean值</p>
<pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(s.has(<span class="hljs-string">&#x27;A&#x27;</span>)); <span class="hljs-comment">// 输出true</span>
<span class="hljs-built_in">console</span>.log(s.has(<span class="hljs-string">&#x27;G&#x27;</span>)); <span class="hljs-comment">// 输出false</span></code></pre>
</li>
<li><p><strong>clear</strong>    清空集合，返回undefined</p>
<pre><code class="hljs js">s.clear();
<span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">// 输出 Set(0) &#123;&#125;</span></code></pre>
</li>
</ul>
</li>
<li><p>集合(Set)实现了iterator接口，所以可以使用==扩展运算符==和==for…of==进行遍历</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> s)&#123;
    <span class="hljs-built_in">console</span>.log(v);	<span class="hljs-comment">// 输出 A B C</span>
&#125;</code></pre>
</li>
<li><p>实例1—数组去重</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>(arr)]; <span class="hljs-comment">// 使用扩展运算符将集合转为数组</span></code></pre>
</li>
<li><p>实例2—交集</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>];

<span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>(arr1)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;
    <span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2);
    <span class="hljs-keyword">if</span>( s2.has(item)) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;)

<span class="hljs-comment">// 简化为下面的写法</span>
<span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>(arr1)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2).has(item));</code></pre>
</li>
<li><p>实例3—并集</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>];

<span class="hljs-keyword">let</span> union = [...arr1, ...arr2];
<span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>(union)];

<span class="hljs-comment">// 简化为下面的写法</span>
<span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>([...arr1, ...arr2])];</code></pre>
</li>
<li><p>实例3—差集</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>];

<span class="hljs-comment">// 差集就是交集的逆运算</span>
<span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>(arr1)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2).has(item));</code></pre>

</li>
</ul>
<h2 id="15-Map"><a href="#15-Map" class="headerlink" title="15.Map"></a>15.Map</h2><ul>
<li><p>ES6提供了<strong>Map</strong>数据结构</p>
<pre><code class="hljs js"><span class="hljs-comment">// 声明Map</span>
<span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();</code></pre>
</li>
<li><p><strong>Map</strong>类似于对象，也是键值对的集合。但是”键”的范围不限于字符串，各种类型的值(包括对象)都可以当作键</p>
</li>
<li><p><strong>Map</strong>的属性和方法</p>
<ul>
<li><p><strong>size</strong>    返回<strong>Map</strong>的元素个数</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-built_in">console</span>.log(m.size); <span class="hljs-comment">// 输出 0</span></code></pre>
</li>
<li><p><strong>set</strong>    添加一个新元素，返回当前<strong>Map</strong></p>
<pre><code class="hljs js">m.set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>);

<span class="hljs-comment">// 键可以是各种类型的字符串</span>
<span class="hljs-keyword">let</span>  key = &#123;
    name: <span class="hljs-string">&#x27;fruit&#x27;</span>
&#125;
m.set(key, [<span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;pear&#x27;</span>]);</code></pre>
</li>
<li><p><strong>delete</strong>   删除一个元素，返回boolean值</p>
<pre><code class="hljs js">m.delete(<span class="hljs-string">&#x27;name&#x27;</span>);</code></pre>
</li>
<li><p><strong>get</strong>    返回键名对象的键值</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> result = m.get(<span class="hljs-string">&#x27;name&#x27;</span>);
  <span class="hljs-built_in">console</span>.log(result);</code></pre>
</li>
<li><p><strong>has</strong>    检测<strong>Map</strong>中是否包含某个元素，返回boolean值</p>
<pre><code class="hljs js">m.has(<span class="hljs-string">&#x27;name&#x27;</span>);</code></pre>
</li>
<li><p><strong>clear</strong>    清空集合，返回undefined</p>
<pre><code class="hljs js">m.clear();</code></pre>
</li>
<li><p><strong>keys</strong>    将Map对象的每个元素的键构成一个<strong>iterator</strong>对象，将其返回</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]);
<span class="hljs-built_in">console</span>.log(map.keys()); <span class="hljs-comment">// [&#x27;1&#x27;, &#x27;2&#x27;]</span></code></pre>
</li>
<li><p><strong>values</strong>    将Map对象的每个元素的值构成一个<strong>iterator</strong>对象，将其返回</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]]);
<span class="hljs-built_in">console</span>.log(map.values()); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></code></pre>
</li>
</ul>
</li>
<li><p><strong>Map</strong>也实现了iterator接口，所以可以使用==扩展运算符==和==for…of==进行遍历</p>
<pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> m)&#123;
    <span class="hljs-built_in">console</span>.log(v);
&#125;</code></pre>

</li>
</ul>
<h2 id="16-Class类"><a href="#16-Class类" class="headerlink" title="16.Class类"></a>16.Class类</h2><ul>
<li><p>ES6提供了更接近传统语言的写法，引入了<strong>Class</strong>(类)这个概念，作为对象的模板</p>
</li>
<li><p>基本上，ES6的<strong>class</strong>可以看作只是一个语法糖，他的绝大部分功能，ES5都可以做到，新的<strong>class</strong>写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已</p>
<pre><code class="hljs js"><span class="hljs-comment">// ES5中通过构造函数实例化对象</span>

<span class="hljs-comment">// 构造手机</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Phone</span>(<span class="hljs-params">brand, price</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.brand = brand;
    <span class="hljs-built_in">this</span>.price = price;
&#125;

<span class="hljs-comment">// 添加方法</span>
Phone.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);
&#125;

<span class="hljs-comment">// 实例化对象</span>
<span class="hljs-keyword">let</span> Huawei = <span class="hljs-keyword">new</span> Phone(<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-number">999</span>);
<span class="hljs-comment">// 调用内部的方法</span>
Huawei.call();</code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// 用ES6的class语法实现上面的例子</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-comment">// 构造方法，名字时固定的，在使用new实例化对象时自动调用该函数</span>
    <span class="hljs-keyword">constructor</span>(brand, price)&#123;
        <span class="hljs-built_in">this</span>.brand = brand;
        <span class="hljs-built_in">this</span>.price = price;
    &#125;;
    <span class="hljs-comment">// 添加方法必须是下面的格式，不能使用ES5的格式</span>
    call() &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);
    &#125;;
&#125;

<span class="hljs-comment">// 实例化对象</span>
<span class="hljs-keyword">let</span> Huawei = <span class="hljs-keyword">new</span> Phone(<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-number">999</span>);</code></pre>
</li>
<li><p>类的静态成员</p>
<pre><code class="hljs js"><span class="hljs-comment">// ES5</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Phone</span>(<span class="hljs-params"></span>) </span>&#123;
&#125;
<span class="hljs-comment">// 构造函数也是一个对象，可以给构造函数添加属性</span>
<span class="hljs-comment">// 这里的name和call是构造函数的属性，不是实例化对象的属性，这样的属性称为静态成员</span>
Phone.name = <span class="hljs-string">&#x27;手机&#x27;</span>;
Phone.call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);
&#125;
<span class="hljs-comment">// 实例化对象</span>
<span class="hljs-keyword">let</span> Huawei = <span class="hljs-keyword">new</span> Phone();

<span class="hljs-comment">// 实例化对象与构造函数的属性的属性不共通</span>
<span class="hljs-built_in">console</span>.log(Huawei.name); <span class="hljs-comment">// 返回 undefined</span>
Huawei.call();  <span class="hljs-comment">// 报错</span>

<span class="hljs-comment">// 实例化对象与构造函数原型对象的属性共通</span>
Phone.prototype.size = <span class="hljs-string">&#x27;5.5inch&#x27;</span>;
<span class="hljs-built_in">console</span>.log(Huawei.size); <span class="hljs-comment">// 返回 5.5inch  </span></code></pre>

<pre><code class="hljs js"><span class="hljs-comment">// ES6</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;
  <span class="hljs-comment">// 静态属性</span>
  <span class="hljs-keyword">static</span> name = <span class="hljs-string">&#x27;手机&#x27;</span>;
  <span class="hljs-keyword">static</span> call()&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);
  &#125;
&#125;
<span class="hljs-comment">// 实例化</span>
<span class="hljs-keyword">let</span> nokia = <span class="hljs-keyword">new</span> Phone();
<span class="hljs-built_in">console</span>.log(nokia.name); <span class="hljs-comment">// 输出 undefined</span>
<span class="hljs-built_in">console</span>.log(Phone.name); <span class="hljs-comment">// 输出 手机</span></code></pre>



</li>
</ul>
<ul>
<li><p>对象继承</p>
<pre><code class="hljs js"><span class="hljs-comment">// ES5</span>
<span class="hljs-comment">// 构造手机</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Phone</span>(<span class="hljs-params">brand, price</span>) </span>&#123;
    <span class="hljs-built_in">this</span>.brand = brand;
    <span class="hljs-built_in">this</span>.price = price;
&#125;

Phone.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);
&#125;

<span class="hljs-comment">// 构造智能手机</span>
<span class="hljs-comment">// 智能手机应该有手机的一切属性，不必要再写重复的代码，可以使用继承</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SmartPhone</span>(<span class="hljs-params">brand, price, color, size</span>) </span>&#123;
    <span class="hljs-comment">// 继承</span>
    Phone.call(<span class="hljs-built_in">this</span>, brand, price);
    <span class="hljs-comment">// 初始化独有的属性</span>
    <span class="hljs-built_in">this</span>.color = color;
    <span class="hljs-built_in">this</span>.size = size;
    <span class="hljs-comment">// 设置子级构造函数的原型</span>
    SmartPhone.prototype = <span class="hljs-keyword">new</span> Phone;
    <span class="hljs-comment">// 校正</span>
    SmartPhone.prototype.constructor = SmartPhone;
    
    <span class="hljs-comment">// 声明子类的方法</span>
    SmartPhone.prototype.photo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以拍照&#x27;</span>);
    &#125;
&#125;

<span class="hljs-comment">// 实例化对象</span>
<span class="hljs-keyword">const</span> xiaomi = <span class="hljs-keyword">new</span> SmartPhone(<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-number">2999</span>, <span class="hljs-string">&#x27;白色&#x27;</span>, <span class="hljs-string">&#x27;5.5inch&#x27;</span>);</code></pre>
</li>
<li><p>类继承</p>
<pre><code class="hljs js"><span class="hljs-comment">// ES6</span>
<span class="hljs-comment">// 构造手机(父类)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-comment">// 构造方法</span>
    <span class="hljs-keyword">constructor</span>(brand, price) &#123;
        <span class="hljs-built_in">this</span>.brand = brand;
        <span class="hljs-built_in">this</span>.price = price;
    &#125;
    <span class="hljs-comment">// 父类的成员属性</span>
    call() &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);
    &#125;
&#125;

<span class="hljs-comment">// 构造智能手机(子类)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span> </span>&#123;
    <span class="hljs-comment">// 构造方法</span>
    <span class="hljs-keyword">constructor</span>(brand, price, color, size)&#123;
        <span class="hljs-built_in">super</span>(brand, price); <span class="hljs-comment">// super即为父类的构造方法函数</span>
        					 <span class="hljs-comment">// 等于ES5的Phone.call(this, brand, price)</span>
        <span class="hljs-built_in">this</span>.color = color;
        <span class="hljs-built_in">this</span>.size = size;
    &#125;
    
    <span class="hljs-comment">// 子类独有的方法 </span>
    photo() &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以拍照&#x27;</span>);
    &#125;
    <span class="hljs-comment">// 子类对父类方法的重写</span>
    call() &#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以视频通话&#x27;</span>);
    &#125;
&#125;
<span class="hljs-comment">// 实例化对象</span>
<span class="hljs-keyword">const</span> xiaomi = <span class="hljs-keyword">new</span> SmartPhone(<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-number">2999</span>, <span class="hljs-string">&#x27;白色&#x27;</span>, <span class="hljs-string">&#x27;5.5inch&#x27;</span>);</code></pre>
</li>
<li><p><strong>get</strong>和<strong>set</strong></p>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;
    <span class="hljs-comment">// 当调用price属性时就会调用此函数</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title">price</span>()&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;price属性被读取了&#x27;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;aaa&#x27;</span>;
    &#125;
    <span class="hljs-comment">// 当修改price属性时就会调用此函数，必须要有参数</span>
    <span class="hljs-keyword">set</span> <span class="hljs-title">price</span>(<span class="hljs-params">value</span>)&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;price属性被修改了&#x27;</span>);
    &#125;
&#125;
<span class="hljs-keyword">let</span> xiaomi = <span class="hljs-keyword">new</span> Phone();
<span class="hljs-built_in">console</span>.log(xiaomi.price); <span class="hljs-comment">// 返回 price属性被读取了  和  aaa</span>
					  <span class="hljs-comment">// 前者是执行了get,后者是s.price的返回值</span>
xiaomi.price = <span class="hljs-string">&#x27;free&#x27;</span>; <span class="hljs-comment">// 此时会输出 price属性被修改了</span></code></pre>

</li>
</ul>
<h2 id="17-数值扩展"><a href="#17-数值扩展" class="headerlink" title="17.数值扩展"></a>17.数值扩展</h2><ul>
<li><p><strong>Number.EPSILON</strong></p>
<ul>
<li><p><strong>Number.EPSILON</strong>是javascript表示的最小精度</p>
</li>
<li><p><strong>Number.EPSILON</strong>的值接近于2.220446049250313e-16，即2的-52次方</p>
</li>
<li><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围</p>
<pre><code class="hljs js"><span class="hljs-comment">// 浮点数计算是不精确的</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>); <span class="hljs-comment">// 输出 0.30000000000000004</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span>); <span class="hljs-comment">// 输出fasle</span>

<span class="hljs-comment">// 判断两个浮点数是否相等</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equal</span>(<span class="hljs-params">a, b</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Math</span>.abs(a - b) &lt; <span class="hljs-built_in">Number</span>.EPSILON)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> fasle;
    &#125;
&#125;

<span class="hljs-built_in">console</span>.log(equal(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// 输出true</span></code></pre>
</li>
</ul>
</li>
<li><p>二进制和八进制和十六进制</p>
<ul>
<li><p>二进制  0b</p>
<p><code>let b = 0b1010;</code></p>
</li>
<li><p>八进制  0o</p>
<p><code>let o = 0o777;</code></p>
</li>
<li><p>十六进制  0x</p>
<p><code>let x = 0xff;</code></p>
</li>
</ul>
</li>
<li><p><strong>Number.isFinite</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 判断一个数是否为有限数</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isFinite(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 输出 true</span></code></pre>
</li>
<li><p><strong>Number.isNaN</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 检测一个数值是否为NaN</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(<span class="hljs-number">123</span>)); <span class="hljs-comment">// 输出 false</span></code></pre>
</li>
<li><p><strong>Number.parseInt</strong>        <strong>Number.parseFloat</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 将字符串转为数字</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.parseInt(<span class="hljs-string">&#x27;123456abc&#x27;</span>)); <span class="hljs-comment">// 输出 123456</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.parseFloat(<span class="hljs-string">&#x27;1.23456abc&#x27;</span>)); <span class="hljs-comment">// 输出 1.23456</span></code></pre>
</li>
<li><p><strong>Number.isInteger</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 判断一个数是否为整数</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isInterger(<span class="hljs-number">5.1</span>)); <span class="hljs-comment">// 输出 false</span></code></pre>
</li>
<li><p><strong>Math.trunc</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 将数字的小数部分抹掉</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.trunc(<span class="hljs-number">1.234</span>)); <span class="hljs-comment">// 输出 1</span></code></pre>
</li>
<li><p><strong>Math.sign</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 判断一个数是正数负数或0</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 0</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">-4</span>)); <span class="hljs-comment">// 输出 -1</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.sign(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 1</span></code></pre>

</li>
</ul>
<h2 id="18-对象方法扩展"><a href="#18-对象方法扩展" class="headerlink" title="18.对象方法扩展"></a>18.对象方法扩展</h2><ul>
<li><p><strong>Object.is</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 判断两个值是否完全相等</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-number">123</span>, <span class="hljs-number">124</span>)); <span class="hljs-comment">// 输出 false</span>

<span class="hljs-comment">// 与 === 相似但有不同</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// 输出 true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// 输出 false</span></code></pre>
</li>
<li><p><strong>Object.assign</strong></p>
<pre><code class="hljs js"><span class="hljs-comment">// 对象的合并</span>
<span class="hljs-keyword">const</span> config1 = &#123;
    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,
    port: <span class="hljs-number">8080</span>,
    user: <span class="hljs-string">&#x27;root&#x27;</span>,
    password: <span class="hljs-string">&#x27;root&#x27;</span>，
    test1: <span class="hljs-string">&#x27;test1&#x27;</span>
&#125;
<span class="hljs-keyword">const</span> config2 = &#123;
    host: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,
    port: <span class="hljs-number">5500</span>,
    user: <span class="hljs-string">&#x27;admin&#x27;</span>,
    password: <span class="hljs-string">&#x27;admin&#x27;</span>,
    test2: <span class="hljs-string">&#x27;test2&#x27;</span>
&#125;

<span class="hljs-comment">// Object.assign(被覆盖的对象/模板, 用来覆盖的对象)</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Object</span>.assign(config1, config2);
<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// 重名的属性直接覆盖,config1有而config2没有的属性不变</span>
					 <span class="hljs-comment">// config2有而config1没有的属性也会被添加</span></code></pre>
</li>
<li><p><strong>Object.setPrototypeOf</strong>        <strong>Object.getPrototypeOf</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> school = &#123;
    name: <span class="hljs-string">&#x27;北大&#x27;</span>
&#125;
<span class="hljs-keyword">const</span> city = &#123;
    xiaoqu: <span class="hljs-string">&#x27;北京&#x27;</span>
&#125;
<span class="hljs-comment">// 设置原型对象</span>
<span class="hljs-built_in">Object</span>.setPrototypeOf(school, city);
<span class="hljs-built_in">console</span>.log(school);
<span class="hljs-comment">// 获取原型对象</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(school));</code></pre>



</li>
</ul>
<h2 id="19-模块化语法"><a href="#19-模块化语法" class="headerlink" title="19.模块化语法"></a>19.模块化语法</h2><ul>
<li><strong>export</strong>        用于规定模块的对外接口</li>
<li><strong>import</strong>        用于输入其他模块提供的功能</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/08/29/CSS3%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7---%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSS3新增属性</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "ES6新特性&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
